<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Split XLSX -> CSV (by links)</title>
    <style>
        body {
            font-family: system-ui, Arial;
            max-width: 900px;
            margin: 40px auto;
            padding: 16px;
            line-height: 1.5;
            color: #222;
        }

        h1 {
            margin-top: 0;
        }

        .row {
            margin: 10px 0;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            min-width: 160px;
        }

        input[type="text"],
        input[type="number"],
        select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
            min-width: 220px;
        }

        button {
            padding: 10px 14px;
            border-radius: 8px;
            border: none;
            background: #0b5cff;
            color: white;
            cursor: pointer;
        }

        button:disabled {
            background: #999;
            cursor: not-allowed;
        }

        pre {
            background: #f6f8fa;
            padding: 12px;
            border-radius: 8px;
            overflow: auto;
        }

        .log {
            margin-top: 16px;
        }
    </style>

    <!-- SheetJS (xlsx) and JSZip from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
</head>

<body>
    <h1>Split XLSX → Multiple CSV (links)</h1>
    <p>Upload file XLSX chứa các link (hoặc nhiều ô có URL). Tool sẽ tìm URL trong mọi ô, gom thành danh sách, chia theo
        số link / file do bạn nhập và đóng gói thành 1 ZIP để tải.</p>

    <div class="row">
        <label for="xlsxFile">Chọn file .xlsx</label>
        <input id="xlsxFile" type="file" accept=".xlsx,.xls" />
    </div>

    <div class="row">
        <label for="prefix">Tiền tố tên file</label>
        <input id="prefix" type="text" value="links" />
    </div>

    <div class="row">
        <label for="linksPerFile">Số link / file</label>
        <input id="linksPerFile" type="number" min="1" value="100" />
    </div>

    <div class="row">
        <label for="startIndex">Số thứ tự bắt đầu (sequence start)</label>
        <input id="startIndex" type="number" min="0" value="1" />
    </div>

    <div class="row">
        <label for="uniqueOnly">Loại bỏ trùng lặp?</label>
        <select id="uniqueOnly">
            <option value="true">Có (mặc định)</option>
            <option value="false">Không</option>
        </select>
    </div>

    <div class="row">
        <button id="processBtn">Process & Download ZIP</button>
        <button id="previewBtn">Preview links (console)</button>
    </div>

    <div class="log" id="log"></div>

    <script>
        (function () {
            const xlsxFile = document.getElementById('xlsxFile');
            const prefixInput = document.getElementById('prefix');
            const linksPerFileInput = document.getElementById('linksPerFile');
            const startIndexInput = document.getElementById('startIndex');
            const processBtn = document.getElementById('processBtn');
            const previewBtn = document.getElementById('previewBtn');
            const uniqueOnlySelect = document.getElementById('uniqueOnly');
            const logEl = document.getElementById('log');

            function log(msg, isErr = false) {
                const p = document.createElement('div');
                p.textContent = msg;
                p.style.color = isErr ? 'crimson' : '#222';
                logEl.prepend(p);
            }

            // regex to find http/https links in text
            const urlRegex = /(https?:\/\/[^\s"'<>,;]+)/gi;

            function extractLinksFromSheet(workbook) {
                const links = [];
                workbook.SheetNames.forEach(sheetName => {
                    const sheet = workbook.Sheets[sheetName];
                    if (!sheet) return;
                    const range = XLSX.utils.decode_range(sheet['!ref'] || "A1:A1");
                    for (let R = range.s.r; R <= range.e.r; ++R) {
                        for (let C = range.s.c; C <= range.e.c; ++C) {
                            const cell_address = { c: C, r: R };
                            const cell_ref = XLSX.utils.encode_cell(cell_address);
                            const cell = sheet[cell_ref];
                            if (!cell) continue;
                            const text = (cell.w || cell.v || '').toString();
                            const matches = text.match(urlRegex);
                            if (matches) {
                                matches.forEach(m => links.push(m.trim()));
                            }
                        }
                    }
                });
                return links;
            }

            function splitArray(arr, size) {
                const out = [];
                for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
                return out;
            }

            function csvFromArray(arr) {
                // simple CSV: each link in new line, no header.
                // If link contains CR/LF or quotes, escape.
                return arr.map(v => {
                    if (v == null) return '';
                    const s = v.toString().replace(/\r\n/g, ' ').replace(/\n/g, ' ');
                    if (s.includes(',') || s.includes('"') || s.includes('\n')) {
                        return '"' + s.replace(/"/g, '""') + '"';
                    }
                    return s;
                }).join('\r\n');
            }

            async function processFile(file) {
                if (!file) { log('Chưa chọn file!', true); return; }
                try {
                    log('Đang đọc file...');

                    const data = await file.arrayBuffer();
                    const workbook = XLSX.read(data, { type: "array" });

                    let links = extractLinksFromSheet(workbook);
                    log(`Tìm thấy tổng cộng ${links.length} link (trước xử lý).`);

                    const uniqueOnly = uniqueOnlySelect.value === 'true';
                    if (uniqueOnly) {
                        const set = new Set(links);
                        links = Array.from(set);
                        log(`Bỏ trùng lặp → còn ${links.length} link.`);
                    }

                    if (links.length === 0) {
                        log('Không tìm thấy link nào trong file.', true);
                        return;
                    }

                    const perFile = parseInt(linksPerFileInput.value, 10);
                    if (!perFile || perFile <= 0) {
                        log('Số link / file không hợp lệ.', true);
                        return;
                    }

                    const startSeq = parseInt(startIndexInput.value, 10) || 0;
                    const parts = splitArray(links, perFile);

                    const zip = new JSZip();
                    for (let i = 0; i < parts.length; ++i) {
                        const seq = startSeq + i;
                        const countLinks = parts[i].length;
                        // filename: prefix_seq_countlinks.csv
                        const safePrefix = (prefixInput.value || 'output').replace(/[^a-zA-Z0-9_\-]/g, '_');
                        const filename = `${safePrefix}_${seq}.csv`;
                        const csv = csvFromArray(parts[i]);
                        zip.file(filename, csv);
                        log(`Tạo: ${filename} (${countLinks} links)`);
                    }

                    log('Đang nén zip...');
                    const content = await zip.generateAsync({ type: "blob" });
                    const blobUrl = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    const timeStr = new Date().toISOString().replace(/[:.]/g, '-');
                    a.href = blobUrl;
                    a.download = `${(prefixInput.value || 'links')}_split_${timeStr}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(blobUrl);
                    log('Đã tạo và tải xuống ZIP thành công.');
                } catch (err) {
                    console.error(err);
                    log('Lỗi: ' + (err.message || err), true);
                }
            }

            // Preview: just print first 200 links to console
            previewBtn.addEventListener('click', async () => {
                const f = xlsxFile.files[0];
                if (!f) { log('Chưa chọn file để preview.', true); return; }
                try {
                    const data = await f.arrayBuffer();
                    const workbook = XLSX.read(data, { type: "array" });
                    let links = extractLinksFromSheet(workbook);
                    if (uniqueOnlySelect.value === 'true') links = Array.from(new Set(links));
                    console.log('=== Preview links ===');
                    console.log(links.slice(0, 200));
                    log(`Preview: in console ${Math.min(200, links.length)} links (tổng ${links.length}).`);
                } catch (err) {
                    console.error(err);
                    log('Preview lỗi: ' + (err.message || err), true);
                }
            });

            processBtn.addEventListener('click', async () => {
                processBtn.disabled = true;
                await processFile(xlsxFile.files[0]);
                processBtn.disabled = false;
            });

        })();
    </script>
</body>

</html>